#!/usr/bin/env ruby
# frozen_string_literal: true

# h2 CLI
#
# ---

require 'colored'
require 'optparse'

begin # {{{
  require 'h2'
rescue LoadError
  $: << File.expand_path('../../lib', __FILE__)
  require 'h2'
end # }}}

# --- parse options {{{

options = {
  body: nil,
  block: false,
  debug: false,
  headers: {},
  goaway: false,
  method: nil,
  tls: {},
  verbose: false
}

OptionParser.new do |o|

  o.banner = 'Usage: h2 [options] URL'

  o.on '-b', '--block', 'block until server closes connection' do
    options[:block] = true
  end

  o.on '--cafile [FILE]', String, 'certificate authority bundle' do |ca|
    raise ArgumentError, "invalid CA file: #{ca}" unless ca && File.exist?(ca)
    options[:tls][:ca_file] = ca
  end

  o.on '--celluloid', 'use celluloid actor pool' do
    require 'h2/client/celluloid'
  end

  o.on '--concurrent', 'use concurrent-ruby thread pool' do
    require 'h2/client/concurrent'
  end

  o.on '-d', '--data [DATA]', String, 'post body data' do |d|
    options[:method] = :post if options[:method].nil?
    options[:body] = d
  end

  o.on '--debug', 'debug output' do
    options[:debug] = true
  end

  o.on '-sse', '--eventsource', 'send event-stream headers and print messages as they arrive' do
    options[:headers]['accept'] = H2::EVENT_SOURCE_CONTENT_TYPE
  end

  o.on '-g', '--goaway', 'send GOAWAY frame when stream is complete' do
    options[:goaway] = true
  end

  o.on '-h', '--help', 'show this help/usage' do
    puts o
    exit
  end

  o.on '-H [VALUE]', '--header [VALUE]', String, 'include header in request (format: "key: value")' do |h|
    kv = h.split(':').map &:strip
    options[:headers][kv[0]] = kv[1]
  end

  o.on '-v', '--verbose', 'turn on verbosity' do
    options[:verbose] = true
  end

  o.on '-X', '--request [METHOD]', String, 'request method' do |m|
    meth = m.downcase.to_sym
    raise ArgumentError, "invalid method: #{m}" unless H2::REQUEST_METHODS.include? meth
    options[:method] = meth
  end

  o.on '--version', 'print version information' do
    puts "#{H2::USER_AGENT['user-agent']} using http-2-#{HTTP2::VERSION}"
    exit
  end

end.parse!

options[:method] ||= :get
options[:tls][:ca_file] ||= ENV['H2_CAFILE'] if ENV['H2_CAFILE']

# }}}

# --- parse URL {{{

url = ARGV[0]
url = 'https://' + url unless url.start_with? 'http'
url = URI.parse url

# }}}

# --- build & connect client {{{

client = {
  url: url
}

client[:tls] = options[:tls] unless options[:tls].empty?

c = H2::Client.new **client do |c|
  if options[:debug]
    c.client.on(:frame_received) {|f| puts "<< #{f.inspect}".yellow}
    c.client.on(:frame_sent)     {|f| puts ">> #{f.inspect}".green}
  end
end

# }}}

# --- build & send request {{{

request = {
  body: options[:body],
  headers: options[:headers],
  path: url.request_uri
}

if options[:verbose]
  c.build_headers(
    method: options[:method],
    path: url.request_uri,
    headers: request[:headers]
  ).each {|k,v| puts ">> #{k}: #{v}".green}
end

s = c.__send__ options[:method], **request

# }}}

# --- print response & close {{{

if options[:verbose]
  s.headers.each {|k,v| puts "<< #{k}: #{v}".yellow}
end

if s.eventsource?
  s.body {|e| puts e}
else
  puts s.body
end

c.block! if options[:block] or !s.pushes.empty?
s.pushes.each do |p|
  puts "push promise: #{p.headers[':path']}"
end

c.goaway if options[:goaway]
c.close

# }}}

# vim: ft=ruby fdm=marker fdl=0
